// Generated by lexgen
package org.jmlspecs.checker;
import org.multijava.util.compiler.CToken;

/*package*/ final class JmlTopIDKeywords implements JmlTopIDTokenTypes {
  public static CToken lookup(final char[] data, int offset, int length) {
    return tokens[find(data, offset, length) + 1];
  }
  private static final CToken[] tokens = new CToken[] {
    null,
    new CToken(LITERAL_abstract, "abstract", 0),
    new CToken(LITERAL_assert, "assert", 0),
    new CToken(LITERAL_boolean, "boolean", 0),
    new CToken(LITERAL_break, "break", 0),
    new CToken(LITERAL_byte, "byte", 0),
    new CToken(LITERAL_case, "case", 0),
    new CToken(LITERAL_catch, "catch", 0),
    new CToken(LITERAL_char, "char", 0),
    new CToken(LITERAL_class, "class", 0),
    new CToken(LITERAL_const, "const", 0),
    new CToken(LITERAL_continue, "continue", 0),
    new CToken(LITERAL_default, "default", 0),
    new CToken(LITERAL_do, "do", 0),
    new CToken(LITERAL_double, "double", 0),
    new CToken(LITERAL_else, "else", 0),
    new CToken(LITERAL_extends, "extends", 0),
    new CToken(LITERAL_false, "false", 0),
    new CToken(LITERAL_final, "final", 0),
    new CToken(LITERAL_finally, "finally", 0),
    new CToken(LITERAL_float, "float", 0),
    new CToken(LITERAL_for, "for", 0),
    new CToken(LITERAL_goto, "goto", 0),
    new CToken(LITERAL_if, "if", 0),
    new CToken(LITERAL_implements, "implements", 0),
    new CToken(LITERAL_import, "import", 0),
    new CToken(LITERAL_instanceof, "instanceof", 0),
    new CToken(LITERAL_int, "int", 0),
    new CToken(LITERAL_interface, "interface", 0),
    new CToken(LITERAL_long, "long", 0),
    new CToken(LITERAL_native, "native", 0),
    new CToken(LITERAL_new, "new", 0),
    new CToken(LITERAL_null, "null", 0),
    new CToken(LITERAL_package, "package", 0),
    new CToken(LITERAL_private, "private", 0),
    new CToken(LITERAL_protected, "protected", 0),
    new CToken(LITERAL_public, "public", 0),
    new CToken(LITERAL_peer, "peer", 0),
    new CToken(LITERAL_readonly, "readonly", 0),
    new CToken(LITERAL_rep, "rep", 0),
    new CToken(LITERAL_pure, "pure", 0),
    new CToken(LITERAL_resend, "resend", 0),
    new CToken(LITERAL_return, "return", 0),
    new CToken(LITERAL_short, "short", 0),
    new CToken(LITERAL_static, "static", 0),
    new CToken(LITERAL_strictfp, "strictfp", 0),
    new CToken(LITERAL_super, "super", 0),
    new CToken(LITERAL_switch, "switch", 0),
    new CToken(LITERAL_synchronized, "synchronized", 0),
    new CToken(LITERAL_this, "this", 0),
    new CToken(LITERAL_throw, "throw", 0),
    new CToken(LITERAL_throws, "throws", 0),
    new CToken(LITERAL_transient, "transient", 0),
    new CToken(LITERAL_true, "true", 0),
    new CToken(LITERAL_try, "try", 0),
    new CToken(LITERAL_void, "void", 0),
    new CToken(LITERAL_volatile, "volatile", 0),
    new CToken(LITERAL_while, "while", 0),
    new CToken(LITERAL__warn, "_warn", 0),
    new CToken(LITERAL__warn_op, "_warn_op", 0),
    new CToken(LITERAL__nowarn, "_nowarn", 0),
    new CToken(LITERAL__nowarn_op, "_nowarn_op", 0)
  };
  public final static int INSIDE_ANNOTATION = 1;

 // --------------------------------------------------------------------
 // CODE GENERATED BY JPERF STARTS HERE

  private static final int MAX_GRAPH_NODE_VAL = 128;

  private static final int MIN_CHAR_VAL = '_';
  private static final int MAX_CHAR_VAL = 'z';
  private static final int MIN_WORD_LENG = 2;
  private static final int MAX_WORD_LENG = 12;
  private static final int TOTAL_KEYWORDS = 61;
  private static final char[][] keywords = new char[][] {
    "abstract".toCharArray(),
    "assert".toCharArray(),
    "boolean".toCharArray(),
    "break".toCharArray(),
    "byte".toCharArray(),
    "case".toCharArray(),
    "catch".toCharArray(),
    "char".toCharArray(),
    "class".toCharArray(),
    "const".toCharArray(),
    "continue".toCharArray(),
    "default".toCharArray(),
    "do".toCharArray(),
    "double".toCharArray(),
    "else".toCharArray(),
    "extends".toCharArray(),
    "false".toCharArray(),
    "final".toCharArray(),
    "finally".toCharArray(),
    "float".toCharArray(),
    "for".toCharArray(),
    "goto".toCharArray(),
    "if".toCharArray(),
    "implements".toCharArray(),
    "import".toCharArray(),
    "instanceof".toCharArray(),
    "int".toCharArray(),
    "interface".toCharArray(),
    "long".toCharArray(),
    "native".toCharArray(),
    "new".toCharArray(),
    "null".toCharArray(),
    "package".toCharArray(),
    "private".toCharArray(),
    "protected".toCharArray(),
    "public".toCharArray(),
    "peer".toCharArray(),
    "readonly".toCharArray(),
    "rep".toCharArray(),
    "pure".toCharArray(),
    "resend".toCharArray(),
    "return".toCharArray(),
    "short".toCharArray(),
    "static".toCharArray(),
    "strictfp".toCharArray(),
    "super".toCharArray(),
    "switch".toCharArray(),
    "synchronized".toCharArray(),
    "this".toCharArray(),
    "throw".toCharArray(),
    "throws".toCharArray(),
    "transient".toCharArray(),
    "true".toCharArray(),
    "try".toCharArray(),
    "void".toCharArray(),
    "volatile".toCharArray(),
    "while".toCharArray(),
    "_warn".toCharArray(),
    "_warn_op".toCharArray(),
    "_nowarn".toCharArray(),
    "_nowarn_op".toCharArray()
  };

    private static final int[][] T1 = {
    {33,-1,112,72,16,76,68,57,17,-1,37,-1,-1,127,-1,86,-1,75,-1,94,127,44,-1,68,44,-1,-1,-1},
    {-1,-1,2,58,-1,-1,86,68,-1,73,123,-1,-1,106,73,63,75,-1,-1,110,94,117,64,-1,8,19,77,-1},
    {-1,-1,22,86,16,-1,74,67,-1,-1,108,-1,-1,14,-1,60,112,122,-1,21,102,116,3,-1,123,-1,26,-1},
    {-1,-1,37,123,65,77,67,-1,123,-1,8,-1,115,123,-1,105,56,-1,-1,35,62,13,24,94,61,-1,-1,-1},
    {-1,-1,110,-1,107,-1,64,-1,-1,101,106,-1,32,99,-1,86,16,-1,-1,91,52,124,24,4,90,-1,-1,-1},
    {57,-1,63,-1,98,122,3,127,30,102,65,-1,-1,27,95,28,-1,-1,-1,30,13,56,-1,-1,-1,-1,-1,-1},
    {-1,-1,61,-1,56,-1,123,114,-1,-1,-1,-1,-1,67,-1,109,88,-1,-1,-1,3,36,30,-1,-1,-1,30,-1},
    {47,-1,-1,-1,72,-1,102,-1,-1,-1,-1,-1,-1,-1,-1,71,-1,3,-1,-1,-1,107,-1,-1,-1,-1,52,-1},
    {-1,-1,-1,-1,-1,55,47,-1,-1,-1,36,-1,-1,-1,-1,-1,52,-1,-1,-1,-1,116,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,18,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,-1,-1,73,-1,-1,-1,-1,-1,-1,76},
    {-1,-1,-1,-1,-1,-1,115,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,37,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}
    };
    private static final int[][] T2 = {
    {115,-1,120,0,56,88,74,43,118,-1,86,-1,-1,13,-1,57,-1,113,-1,108,27,24,-1,120,79,-1,-1,-1},
    {-1,-1,19,109,-1,-1,126,85,-1,70,3,-1,-1,34,82,66,87,-1,-1,112,79,14,91,-1,83,80,55,-1},
    {-1,-1,119,103,117,-1,14,4,-1,-1,86,-1,-1,114,-1,77,120,36,-1,121,89,99,81,-1,70,-1,50,-1},
    {-1,-1,70,32,121,59,56,-1,79,-1,122,-1,44,0,-1,107,109,-1,-1,30,53,119,22,9,103,-1,-1,-1},
    {-1,-1,110,-1,35,-1,2,-1,-1,10,74,-1,79,42,-1,75,37,-1,-1,68,97,39,86,110,38,-1,-1,-1},
    {70,-1,80,-1,80,43,94,54,26,99,104,-1,-1,48,15,91,-1,-1,-1,84,58,95,-1,-1,-1,-1,-1,-1},
    {-1,-1,71,-1,125,-1,27,111,-1,-1,-1,-1,-1,101,-1,60,109,-1,-1,-1,74,2,33,-1,-1,-1,39,-1},
    {6,-1,-1,-1,99,-1,81,-1,-1,-1,-1,-1,-1,-1,-1,32,-1,59,-1,-1,-1,42,-1,-1,-1,-1,42,-1},
    {-1,-1,-1,-1,-1,46,57,-1,-1,-1,34,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,106,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1,-1,-1,-1,-1,29,-1,-1,35,-1,-1,-1,-1,-1,-1,114},
    {-1,-1,-1,-1,-1,-1,124,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,111,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}
    };

  private static final int MAX_NODE_NUM = 71;
  private static final int gIndex(int n) {
    switch(n) {
    case 90:
    case 112:
    case 10:
    case 106:
    case 69:
    case 59:
    case 81:
    case 23:
    case 120:
    case 8:
    case 1:
    case 45:
      return 0;
    case 123:
      return 1;
    case 93:
      return 2;
    case 19:
      return 3;
    case 76:
      return 43;
    case 82:
      return 22;
    case 92:
      return 5;
    case 44:
      return 5;
    case 49:
      return 1;
    case 18:
      return 4;
    case 2:
      return 48;
    case 103:
      return 21;
    case 56:
      return 9;
    case 46:
      return 10;
    case 97:
      return 60;
    case 40:
      return 12;
    case 47:
      return 12;
    case 87:
      return 17;
    case 125:
      return 58;
    case 117:
      return 16;
    case 71:
      return 56;
    case 107:
      return 17;
    case 66:
      return 17;
    case 52:
      return 27;
    case 50:
      return 53;
    case 25:
      return 19;
    case 29:
      return 21;
    case 105:
      return 11;
    case 43:
      return 11;
    case 37:
      return 23;
    case 51:
      return 19;
    case 30:
      return 25;
    case 88:
      return 25;
    case 41:
      return 29;
    case 16:
      return 59;
    case 0:
      return 28;
    case 91:
      return 13;
    case 39:
      return 33;
    case 31:
      return 37;
    case 6:
      return 55;
    case 72:
      return 15;
    case 36:
      return 21;
    case 35:
      return 15;
    case 77:
      return 23;
    case 14:
      return 28;
    case 27:
      return 8;
    case 58:
      return 26;
    case 99:
      return 42;
    case 113:
      return 40;
    case 55:
      return 54;
    case 22:
      return 28;
    case 65:
      return 46;
    case 115:
      return 60;
    case 28:
      return 49;
    case 68:
      return 26;
    case 96:
      return 39;
    case 17:
      return 13;
    case 109:
      return 7;
    case 38:
      return 48;
    case 20:
      return 15;
    default:
      return -1;
    }
  }


  private static final boolean equals(final char[] key, int offset, int length, final char[] word) {
    if (word.length != length) {
      return false;
    } else {
      for (int i = 0; i < length; i++) {
	 if (word[i] != key[offset + i]) {
	   return false;
	 }
      }
      return true;
    }
  }

  private static final int hash(final char[] key, int offset, int length) {
    int		f1 = 0;
    int		f2 = 0;

    for (int i = 0; i < length; i++) {
      char	c = key[i + offset];

      if (c < MIN_CHAR_VAL || c > MAX_CHAR_VAL) {
	return -1;
      }

      int	t1 = T1[i][c - MIN_CHAR_VAL];
      if (t1 == -1) {
	return -1;
      }

      int	t2 = T2[i][c - MIN_CHAR_VAL];
      if (t2 == -1) {
	return -1;
      }

      f1 += t1;
      f2 += t2;
    }

    f1 %= MAX_GRAPH_NODE_VAL;
    f2 %= MAX_GRAPH_NODE_VAL;

    return (gIndex(f1)+gIndex(f2)) % TOTAL_KEYWORDS;
  }

  private static final int find(final char[] key, int offset, int length) {
    if (length <= MAX_WORD_LENG && length >= MIN_WORD_LENG) {
      int	ind = hash(key, offset, length);

      if (ind < TOTAL_KEYWORDS && ind >= 0) {
	if (equals(key, offset, length, keywords[ind])) {
	  return ind;
	}
      }
    }
    return -1;
  }

 // CODE GENERATED BY JPERF ENDS HERE
 // --------------------------------------------------------------------

}
