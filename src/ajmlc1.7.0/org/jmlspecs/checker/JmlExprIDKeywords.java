// Generated by lexgen
package org.jmlspecs.checker;
import org.multijava.util.compiler.CToken;

/*package*/ final class JmlExprIDKeywords implements JmlExprIDTokenTypes {
  public static CToken lookup(final char[] data, int offset, int length) {
    return tokens[find(data, offset, length) + 1];
  }
  private static final CToken[] tokens = new CToken[] {
    null,
    new CToken(LITERAL_abstract, "abstract", 0),
    new CToken(LITERAL_assert, "assert", 0),
    new CToken(LITERAL_boolean, "boolean", 0),
    new CToken(LITERAL_break, "break", 0),
    new CToken(LITERAL_byte, "byte", 0),
    new CToken(LITERAL_case, "case", 0),
    new CToken(LITERAL_catch, "catch", 0),
    new CToken(LITERAL_char, "char", 0),
    new CToken(LITERAL_class, "class", 0),
    new CToken(LITERAL_const, "const", 0),
    new CToken(LITERAL_continue, "continue", 0),
    new CToken(LITERAL_default, "default", 0),
    new CToken(LITERAL_do, "do", 0),
    new CToken(LITERAL_double, "double", 0),
    new CToken(LITERAL_else, "else", 0),
    new CToken(LITERAL_extends, "extends", 0),
    new CToken(LITERAL_false, "false", 0),
    new CToken(LITERAL_final, "final", 0),
    new CToken(LITERAL_finally, "finally", 0),
    new CToken(LITERAL_float, "float", 0),
    new CToken(LITERAL_for, "for", 0),
    new CToken(LITERAL_goto, "goto", 0),
    new CToken(LITERAL_if, "if", 0),
    new CToken(LITERAL_implements, "implements", 0),
    new CToken(LITERAL_import, "import", 0),
    new CToken(LITERAL_instanceof, "instanceof", 0),
    new CToken(LITERAL_int, "int", 0),
    new CToken(LITERAL_interface, "interface", 0),
    new CToken(LITERAL_long, "long", 0),
    new CToken(LITERAL_native, "native", 0),
    new CToken(LITERAL_new, "new", 0),
    new CToken(LITERAL_null, "null", 0),
    new CToken(LITERAL_package, "package", 0),
    new CToken(LITERAL_private, "private", 0),
    new CToken(LITERAL_protected, "protected", 0),
    new CToken(LITERAL_public, "public", 0),
    new CToken(LITERAL_peer, "peer", 0),
    new CToken(LITERAL_readonly, "readonly", 0),
    new CToken(LITERAL_rep, "rep", 0),
    new CToken(LITERAL_pure, "pure", 0),
    new CToken(LITERAL_resend, "resend", 0),
    new CToken(LITERAL_return, "return", 0),
    new CToken(LITERAL_short, "short", 0),
    new CToken(LITERAL_static, "static", 0),
    new CToken(LITERAL_strictfp, "strictfp", 0),
    new CToken(LITERAL_super, "super", 0),
    new CToken(LITERAL_switch, "switch", 0),
    new CToken(LITERAL_synchronized, "synchronized", 0),
    new CToken(LITERAL_this, "this", 0),
    new CToken(LITERAL_throw, "throw", 0),
    new CToken(LITERAL_throws, "throws", 0),
    new CToken(LITERAL_transient, "transient", 0),
    new CToken(LITERAL_true, "true", 0),
    new CToken(LITERAL_try, "try", 0),
    new CToken(LITERAL_void, "void", 0),
    new CToken(LITERAL_volatile, "volatile", 0),
    new CToken(LITERAL_while, "while", 0),
    new CToken(LITERAL__warn, "_warn", 0),
    new CToken(LITERAL__warn_op, "_warn_op", 0),
    new CToken(LITERAL__nowarn, "_nowarn", 0),
    new CToken(LITERAL__nowarn_op, "_nowarn_op", 0),
    new CToken(LITERAL_BS_TYPE, "\\TYPE", 0),
    new CToken(LITERAL_BS_bigint, "\\bigint", 0),
    new CToken(LITERAL_BS_bigint_math, "\\bigint_math", 0),
    new CToken(LITERAL_BS_duration, "\\duration", 0),
    new CToken(LITERAL_BS_elemtype, "\\elemtype", 0),
    new CToken(LITERAL_BS_everything, "\\everything", 0),
    new CToken(LITERAL_BS_exists, "\\exists", 2),
    new CToken(LITERAL_BS_forall, "\\forall", 2),
    new CToken(LITERAL_BS_fresh, "\\fresh", 0),
    new CToken(LITERAL_BS_into, "\\into", 0),
    new CToken(LITERAL_BS_invariant_for, "\\invariant_for", 0),
    new CToken(LITERAL_BS_is_initialized, "\\is_initialized", 0),
    new CToken(LITERAL_BS_java_math, "\\java_math", 0),
    new CToken(LITERAL_BS_lblneg, "\\lblneg", 0),
    new CToken(LITERAL_BS_lblpos, "\\lblpos", 0),
    new CToken(LITERAL_BS_lockset, "\\lockset", 0),
    new CToken(LITERAL_BS_max, "\\max", 2),
    new CToken(LITERAL_BS_min, "\\min", 2),
    new CToken(LITERAL_BS_nonnullelements, "\\nonnullelements", 0),
    new CToken(LITERAL_BS_not_modified, "\\not_modified", 0),
    new CToken(LITERAL_BS_not_assigned, "\\not_assigned", 0),
    new CToken(LITERAL_BS_not_specified, "\\not_specified", 0),
    new CToken(LITERAL_BS_nothing, "\\nothing", 0),
    new CToken(LITERAL_BS_nowarn, "\\nowarn", 0),
    new CToken(LITERAL_BS_nowarn_op, "\\nowarn_op", 0),
    new CToken(LITERAL_BS_num_of, "\\num_of", 2),
    new CToken(LITERAL_BS_old, "\\old", 0),
    new CToken(LITERAL_BS_only_assigned, "\\only_assigned", 0),
    new CToken(LITERAL_BS_only_accessed, "\\only_accessed", 0),
    new CToken(LITERAL_BS_only_called, "\\only_called", 0),
    new CToken(LITERAL_BS_only_captured, "\\only_captured", 0),
    new CToken(LITERAL_BS_other, "\\other", 0),
    new CToken(LITERAL_BS_pre, "\\pre", 0),
    new CToken(LITERAL_BS_product, "\\product", 2),
    new CToken(LITERAL_BS_reach, "\\reach", 0),
    new CToken(LITERAL_BS_real, "\\real", 0),
    new CToken(LITERAL_BS_result, "\\result", 0),
    new CToken(LITERAL_BS_safe_math, "\\safe_math", 0),
    new CToken(LITERAL_BS_same, "\\same", 0),
    new CToken(LITERAL_BS_space, "\\space", 0),
    new CToken(LITERAL_BS_such_that, "\\such_that", 0),
    new CToken(LITERAL_BS_sum, "\\sum", 2),
    new CToken(LITERAL_BS_type, "\\type", 0),
    new CToken(LITERAL_BS_typeof, "\\typeof", 0),
    new CToken(LITERAL_BS_warn, "\\warn", 0),
    new CToken(LITERAL_BS_warn_op, "\\warn_op", 0),
    new CToken(LITERAL_BS_working_space, "\\working_space", 0),
    new CToken(LITERAL_U_peer, "\\peer", 0),
    new CToken(LITERAL_U_rep, "\\rep", 0),
    new CToken(LITERAL_U_readonly, "\\readonly", 0)
  };
  public final static int INSIDE_ANNOTATION = 1;
  public final static int QUANTIFIER = 2;

 // --------------------------------------------------------------------
 // CODE GENERATED BY JPERF STARTS HERE

  private static final int MAX_GRAPH_NODE_VAL = 232;

  private static final int MIN_CHAR_VAL = 'E';
  private static final int MAX_CHAR_VAL = 'z';
  private static final int MIN_WORD_LENG = 2;
  private static final int MAX_WORD_LENG = 16;
  private static final int TOTAL_KEYWORDS = 111;
  private static final char[][] keywords = new char[][] {
    "abstract".toCharArray(),
    "assert".toCharArray(),
    "boolean".toCharArray(),
    "break".toCharArray(),
    "byte".toCharArray(),
    "case".toCharArray(),
    "catch".toCharArray(),
    "char".toCharArray(),
    "class".toCharArray(),
    "const".toCharArray(),
    "continue".toCharArray(),
    "default".toCharArray(),
    "do".toCharArray(),
    "double".toCharArray(),
    "else".toCharArray(),
    "extends".toCharArray(),
    "false".toCharArray(),
    "final".toCharArray(),
    "finally".toCharArray(),
    "float".toCharArray(),
    "for".toCharArray(),
    "goto".toCharArray(),
    "if".toCharArray(),
    "implements".toCharArray(),
    "import".toCharArray(),
    "instanceof".toCharArray(),
    "int".toCharArray(),
    "interface".toCharArray(),
    "long".toCharArray(),
    "native".toCharArray(),
    "new".toCharArray(),
    "null".toCharArray(),
    "package".toCharArray(),
    "private".toCharArray(),
    "protected".toCharArray(),
    "public".toCharArray(),
    "peer".toCharArray(),
    "readonly".toCharArray(),
    "rep".toCharArray(),
    "pure".toCharArray(),
    "resend".toCharArray(),
    "return".toCharArray(),
    "short".toCharArray(),
    "static".toCharArray(),
    "strictfp".toCharArray(),
    "super".toCharArray(),
    "switch".toCharArray(),
    "synchronized".toCharArray(),
    "this".toCharArray(),
    "throw".toCharArray(),
    "throws".toCharArray(),
    "transient".toCharArray(),
    "true".toCharArray(),
    "try".toCharArray(),
    "void".toCharArray(),
    "volatile".toCharArray(),
    "while".toCharArray(),
    "_warn".toCharArray(),
    "_warn_op".toCharArray(),
    "_nowarn".toCharArray(),
    "_nowarn_op".toCharArray(),
    "\\TYPE".toCharArray(),
    "\\bigint".toCharArray(),
    "\\bigint_math".toCharArray(),
    "\\duration".toCharArray(),
    "\\elemtype".toCharArray(),
    "\\everything".toCharArray(),
    "\\exists".toCharArray(),
    "\\forall".toCharArray(),
    "\\fresh".toCharArray(),
    "\\into".toCharArray(),
    "\\invariant_for".toCharArray(),
    "\\is_initialized".toCharArray(),
    "\\java_math".toCharArray(),
    "\\lblneg".toCharArray(),
    "\\lblpos".toCharArray(),
    "\\lockset".toCharArray(),
    "\\max".toCharArray(),
    "\\min".toCharArray(),
    "\\nonnullelements".toCharArray(),
    "\\not_modified".toCharArray(),
    "\\not_assigned".toCharArray(),
    "\\not_specified".toCharArray(),
    "\\nothing".toCharArray(),
    "\\nowarn".toCharArray(),
    "\\nowarn_op".toCharArray(),
    "\\num_of".toCharArray(),
    "\\old".toCharArray(),
    "\\only_assigned".toCharArray(),
    "\\only_accessed".toCharArray(),
    "\\only_called".toCharArray(),
    "\\only_captured".toCharArray(),
    "\\other".toCharArray(),
    "\\pre".toCharArray(),
    "\\product".toCharArray(),
    "\\reach".toCharArray(),
    "\\real".toCharArray(),
    "\\result".toCharArray(),
    "\\safe_math".toCharArray(),
    "\\same".toCharArray(),
    "\\space".toCharArray(),
    "\\such_that".toCharArray(),
    "\\sum".toCharArray(),
    "\\type".toCharArray(),
    "\\typeof".toCharArray(),
    "\\warn".toCharArray(),
    "\\warn_op".toCharArray(),
    "\\working_space".toCharArray(),
    "\\peer".toCharArray(),
    "\\rep".toCharArray(),
    "\\readonly".toCharArray()
  };

    private static final int[][] T1 = {
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,187,-1,-1,189,-1,137,167,194,156,53,205,33,-1,105,-1,-1,157,-1,135,-1,142,-1,88,63,138,-1,88,115,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,175,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,84,67,-1,180,149,77,-1,150,133,115,-1,47,100,167,89,92,-1,72,164,179,137,-1,57,195,164,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,131,-1,-1,-1,-1,-1,-1,-1,165,52,227,-1,164,45,-1,-1,66,-1,-1,157,-1,67,133,78,-1,108,227,204,203,208,61,146,122,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,116,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,136,66,206,72,209,110,101,136,111,-1,197,160,101,69,118,211,-1,96,227,118,112,167,196,147,-1,-1},
    {23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,75,-1,8,-1,155,147,69,-1,-1,124,111,-1,14,68,33,73,161,158,-1,170,30,182,100,179,221,-1,102,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,143,-1,214,-1,167,37,56,216,99,200,116,-1,-1,143,83,167,157,-1,-1,65,139,62,3,-1,-1,-1,20,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,192,-1,39,-1,24,150,191,-1,193,-1,-1,202,31,149,93,161,-1,-1,196,164,181,-1,-1,-1,98,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,217,-1,100,-1,211,2,19,-1,66,25,-1,-1,-1,95,-1,79,101,214,-1,-1,46,101,-1,-1,-1,-1,70,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,125,-1,19,-1,20,0,217,-1,-1,-1,181,-1,-1,24,11,222,191,50,-1,-1,26,128,-1,-1,-1,-1,189,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,46,7,133,192,186,-1,-1,123,-1,68,-1,203,-1,-1,179,23,-1,-1,-1,-1,-1,181},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,143,-1,-1,-1,-1,-1,162,142,77,-1,192,-1,-1,82,-1,14,-1,161,-1,-1,193,82,156,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,74,-1,-1,158,3,184,-1,128,77,-1,-1,-1,123,114,-1,-1,-1,182,171,-1,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,194,202,141,-1,-1,-1,-1,-1,-1,-1,-1,-1,130,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,146},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,22,-1,-1,-1,-1,-1,-1,-1,-1,151,-1,-1,-1,11,-1,-1,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,108,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,176,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1,-1}
    };
    private static final int[][] T2 = {
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,103,-1,-1,194,-1,71,189,128,79,61,141,103,-1,68,-1,-1,188,-1,39,-1,214,-1,177,208,41,-1,72,117,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,99,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,193,70,-1,1,1,138,-1,17,217,26,-1,227,100,126,221,230,-1,65,112,141,67,-1,225,144,24,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,171,-1,-1,-1,-1,-1,-1,-1,6,131,115,-1,57,94,-1,-1,81,-1,-1,65,-1,179,96,228,-1,155,191,104,54,115,50,205,23,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,107,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,120,-1,160,124,177,191,64,10,44,218,124,-1,136,206,220,146,43,183,-1,52,6,9,85,53,147,54,-1,-1},
    {1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,225,-1,190,-1,171,43,178,-1,-1,130,68,-1,184,141,143,142,206,133,-1,87,146,50,223,144,101,-1,90,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,64,-1,82,-1,230,25,184,225,94,170,120,-1,-1,116,13,11,19,-1,-1,60,41,150,38,-1,-1,-1,36,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,36,-1,185,-1,111,59,231,-1,184,-1,-1,176,74,155,172,147,-1,-1,103,70,144,-1,-1,-1,55,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,158,-1,229,-1,60,183,3,-1,104,185,-1,-1,-1,80,-1,199,141,94,-1,-1,119,153,-1,-1,-1,-1,82,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,99,-1,153,-1,78,69,49,-1,-1,-1,76,-1,-1,78,59,90,45,132,-1,-1,150,205,-1,-1,-1,-1,123,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,217,-1,-1,-1,174,70,134,176,136,-1,-1,39,-1,16,-1,227,-1,-1,33,102,-1,-1,-1,-1,-1,187},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,231,-1,-1,-1,-1,-1,208,113,167,-1,40,-1,-1,137,-1,170,-1,163,-1,-1,201,90,56,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,144,-1,-1,106,197,153,-1,133,128,-1,-1,-1,138,48,-1,-1,-1,146,193,-1,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,174,73,-1,-1,-1,-1,-1,-1,-1,-1,-1,77,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,92},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,79,50,-1,-1,-1,-1,-1,-1,-1,-1,44,-1,-1,-1,58,-1,-1,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,167,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,-1,-1,-1,-1,-1,-1},
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,179,-1,-1,-1,-1,-1,-1,-1}
    };

  private static final int MAX_NODE_NUM = 136;
  private static final int gIndex(int n) {
    switch(n) {
    case 145:
    case 152:
    case 41:
    case 53:
    case 89:
    case 48:
    case 18:
    case 197:
    case 13:
    case 46:
    case 154:
    case 7:
    case 182:
    case 12:
    case 73:
    case 113:
    case 194:
    case 151:
    case 178:
    case 61:
    case 96:
    case 167:
    case 115:
    case 29:
    case 99:
    case 163:
      return 0;
    case 211:
      return 1;
    case 199:
      return 2;
    case 191:
      return 3;
    case 149:
      return 4;
    case 112:
      return 5;
    case 116:
      return 87;
    case 36:
      return 30;
    case 141:
      return 33;
    case 203:
      return 85;
    case 49:
      return 6;
    case 63:
      return 54;
    case 120:
      return 66;
    case 67:
      return 10;
    case 47:
      return 11;
    case 68:
      return 12;
    case 174:
      return 27;
    case 107:
      return 97;
    case 72:
      return 108;
    case 79:
      return 17;
    case 39:
      return 18;
    case 179:
      return 108;
    case 119:
      return 16;
    case 142:
      return 17;
    case 81:
      return 18;
    case 210:
      return 19;
    case 170:
      return 20;
    case 212:
      return 21;
    case 206:
      return 22;
    case 77:
      return 5;
    case 181:
      return 18;
    case 169:
      return 3;
    case 202:
      return 70;
    case 66:
      return 26;
    case 123:
      return 17;
    case 168:
      return 28;
    case 92:
      return 29;
    case 90:
      return 30;
    case 125:
      return 31;
    case 85:
      return 1;
    case 188:
      return 77;
    case 6:
      return 68;
    case 220:
      return 35;
    case 87:
      return 7;
    case 146:
      return 37;
    case 83:
      return 11;
    case 132:
      return 9;
    case 136:
      return 33;
    case 1:
      return 41;
    case 160:
      return 39;
    case 198:
      return 57;
    case 114:
      return 17;
    case 193:
      return 24;
    case 190:
      return 21;
    case 195:
      return 18;
    case 102:
      return 47;
    case 117:
      return 48;
    case 166:
      return 50;
    case 111:
      return 20;
    case 158:
      return 12;
    case 224:
      return 40;
    case 100:
      return 45;
    case 129:
      return 8;
    case 101:
      return 43;
    case 171:
      return 55;
    case 135:
      return 56;
    case 155:
      return 81;
    case 21:
      return 11;
    case 40:
      return 58;
    case 126:
      return 103;
    case 17:
      return 33;
    case 215:
      return 62;
    case 176:
      return 89;
    case 37:
      return 35;
    case 28:
      return 15;
    case 185:
      return 34;
    case 150:
      return 97;
    case 175:
      return 82;
    case 80:
      return 69;
    case 9:
      return 85;
    case 70:
      return 97;
    case 58:
      return 94;
    case 76:
      return 16;
    case 64:
      return 88;
    case 226:
      return 75;
    case 164:
      return 106;
    case 31:
      return 21;
    case 177:
      return 61;
    case 51:
      return 51;
    case 45:
      return 63;
    case 222:
      return 18;
    case 147:
      return 74;
    case 209:
      return 66;
    case 124:
      return 11;
    case 110:
      return 81;
    case 140:
      return 77;
    case 133:
      return 44;
    case 84:
      return 90;
    case 54:
      return 15;
    case 88:
      return 84;
    case 22:
      return 94;
    case 218:
      return 64;
    case 30:
      return 31;
    case 62:
      return 96;
    case 229:
      return 90;
    case 98:
      return 83;
    case 25:
      return 99;
    case 10:
      return 30;
    case 162:
      return 61;
    case 157:
      return 89;
    case 109:
      return 77;
    default:
      return -1;
    }
  }


  private static final boolean equals(final char[] key, int offset, int length, final char[] word) {
    if (word.length != length) {
      return false;
    } else {
      for (int i = 0; i < length; i++) {
	 if (word[i] != key[offset + i]) {
	   return false;
	 }
      }
      return true;
    }
  }

  private static final int hash(final char[] key, int offset, int length) {
    int		f1 = 0;
    int		f2 = 0;

    for (int i = 0; i < length; i++) {
      char	c = key[i + offset];

      if (c < MIN_CHAR_VAL || c > MAX_CHAR_VAL) {
	return -1;
      }

      int	t1 = T1[i][c - MIN_CHAR_VAL];
      if (t1 == -1) {
	return -1;
      }

      int	t2 = T2[i][c - MIN_CHAR_VAL];
      if (t2 == -1) {
	return -1;
      }

      f1 += t1;
      f2 += t2;
    }

    f1 %= MAX_GRAPH_NODE_VAL;
    f2 %= MAX_GRAPH_NODE_VAL;

    return (gIndex(f1)+gIndex(f2)) % TOTAL_KEYWORDS;
  }

  private static final int find(final char[] key, int offset, int length) {
    if (length <= MAX_WORD_LENG && length >= MIN_WORD_LENG) {
      int	ind = hash(key, offset, length);

      if (ind < TOTAL_KEYWORDS && ind >= 0) {
	if (equals(key, offset, length, keywords[ind])) {
	  return ind;
	}
      }
    }
    return -1;
  }

 // CODE GENERATED BY JPERF ENDS HERE
 // --------------------------------------------------------------------

}
