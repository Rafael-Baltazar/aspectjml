/*
 * Copyright (C) 2008-2009 Federal University of Pernambuco and 
 * University of Central Florida
 *
 * This file is part of AJML
 *
 * AJML is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * AJML is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AJML; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: Main.java,v 1.0 2009/02/20 16:37:23 henriquerebelo Exp $
 * 
 * This file is based on the original $Id: TransClass.java,v 1.77 2007/02/03 02:04:49 delara Exp $
 * by Yoonsik Cheon
 */

package org.jmlspecs.ajmlrac;

import java.util.ArrayList;
import java.util.Iterator;

import org.jmlspecs.checker.JmlClassDeclaration;
import org.jmlspecs.checker.JmlConstructorDeclaration;
import org.jmlspecs.checker.JmlFieldDeclaration;
import org.jmlspecs.checker.JmlMemberAccess;
import org.jmlspecs.checker.JmlMethodDeclaration;
import org.jmlspecs.checker.JmlRepresentsDecl;
import org.jmlspecs.checker.JmlSourceMethod;
import org.jmlspecs.checker.JmlTypeDeclaration;
import org.multijava.mjc.CField;
import org.multijava.mjc.CType;
import org.multijava.mjc.JBlock;
import org.multijava.mjc.JMethodDeclarationType;

/**
 * A class for translating JML class declarations. The translation 
 * produces a set of assertion check methods for the class and any 
 * necessary fields, e.g., to hold old values. This class implements
 * the <em>Template Method Pattern</em> layed out by the abstract
 * superclass {@link TransType}.
 *
 * @author Henrique Rebelo
 * @version $Revision: 1.0 $
 */

public class TransClass extends TransType {

	// ----------------------------------------------------------------------
	// CONSTRUCTORS
	// ----------------------------------------------------------------------

	/**
	 * Constructs a <code>TransClass</code> object.
	 *
	 * @param classDecl target class declaration to be translated
	 */
	public TransClass(JmlClassDeclaration classDecl) {
		super(classDecl);
		this.classDecl = classDecl;
	}

	// ----------------------------------------------------------------------
	// TRANSLATION
	// ----------------------------------------------------------------------

	/**
	 * Translates a JML field declaration, <code>fieldDecl</code>, e.g.,
	 * handling final, model, spec_public, and spec_protected.
	 *
	 * <p>
	 * If this is a model field and it has no accessor method generated by
	 * <code>represents</code> clauses, generate the following form of
	 * default model accessor method:
	 * 
	 * <pre>
	 * [[... model T m ...;]] ==
	 *   protected T m() {
	 *     throw new JMLNonExecutableException();
	 *   }
	 * </pre>
	 * The generated method declaration is added to the current class,
	 * <code>classDecl</code> and its name is added to the field 
	 * <code>modelMethods</code>.
	 * 
	 * <p> If the given declaration is a ghost field declaration,
	 * generates a pair of ghost field accessor methods (getter and
	 * setter), a private field for storing ghost values, and possibly
	 * an initialization block. The generated code has the following
	 * structure:
	 *
	 * <pre>
	 *  private [static] T v;
	 *  [static] {
	 *     v = initializer;
	 *  }
	 *  public [static] T ghost$v$C() {
	 *     return v;
	 *  } 
	 *  public [static] void ghost$v$C(T x) {
	 *     v = x;
	 *  } 
	 * </pre>
	 *
	 * The generated accessors are added to the current class
	 * declaration, and the new field declaration (with its
	 * initialization block) is stored into the input field
	 * declaration for later pretty-printing in the proper order.
	 *
	 * <pre><jml>
	 * also
	 *   requires fieldDecl != null;
	 *   modifies modelMethods, classDecl.*;
	 * </jml></pre>
	 *
	 * @see #translateRepresents(JmlRepresentsDecl[])
	 * @see #modelMethods
	 */
	protected JmlFieldDeclaration translateField(
			JmlFieldDeclaration fieldDecl) 
	{
		JmlFieldDeclaration fdecl = super.translateField(fieldDecl);
		final CField field = fdecl.getField();
		final long modifiers = field.modifiers();
		if (hasFlag(modifiers, ACC_MODEL)) {
			if (!isAccessorGenerated(field)) {
				JmlMemberAccess access = classDecl.jmlAccess();
				if ( !classDecl.isInterface() && !access.isAbstract() ) {
					JmlRacGenerator.warn(fieldDecl.getTokenReference(), 
							RacMessages.MAY_NOT_EXECUTABLE,
							"References to model field \"" +
							fieldDecl.ident() + "\"");
				}
				addNewMethod(defaultModelFieldAccessor(field));
				setAccessorGenerated(field);
			}
		} else if (hasFlag(modifiers, ACC_GHOST)) {
			//addNewMethod(ghostFieldAccessors(fdecl));
		} /*else if (specAccessorNeeded(modifiers)) {
			addNewMethod(specPublicAccessor(field));
			setAccessorGenerated(field);
		}*/
		return fdecl;
	}

	protected void translateInvariantAsPrecondition(){
		InvariantMethodAdviceAsPreconditionMethod m = new InvariantMethodAdviceAsPreconditionMethod(false, typeDecl, varGen);

		if(Main.aRacOptions.clientAwareChecking()){
			InvariantMethodAdviceAsPreconditionMethodClientAwareChecking mClientAwareChecking = new InvariantMethodAdviceAsPreconditionMethodClientAwareChecking(false, typeDecl, varGen);
			RacNode invariantMethod = (RacNode)mClientAwareChecking.generate();
			addNewMethod((JmlMethodDeclaration)invariantMethod);
		}
		else {
			if(Main.aRacOptions.callSiteInstrumentation()){
				InvariantMethodAdviceAsPreconditionMethodCallSite mCallSite = new InvariantMethodAdviceAsPreconditionMethodCallSite(false, typeDecl, varGen);
				RacNode invariantMethod = (RacNode)mCallSite.generate();
				addNewMethod((JmlMethodDeclaration)invariantMethod);
			}
			if(!Main.aRacOptions.noExecutionSiteInstrumentation()){
				RacNode invariantMethod = (RacNode)m.generate();
				addNewMethod((JmlMethodDeclaration)invariantMethod);	
			}	
		}
		
		
		// translating inner invariants - [[[hemr]]]
		ArrayList inners = typeDecl.inners();
		if(inners.size() > 0){
			for (Iterator iterator = inners.iterator(); iterator.hasNext();) {
				JmlTypeDeclaration currentInnerType = (JmlTypeDeclaration) iterator.next();
				m = new InvariantMethodAdviceAsPreconditionMethod(false, currentInnerType, varGen);

				if(Main.aRacOptions.clientAwareChecking()){
					InvariantMethodAdviceAsPreconditionMethodClientAwareChecking mClientAwareChecking = new InvariantMethodAdviceAsPreconditionMethodClientAwareChecking(false, typeDecl, varGen);
					RacNode invariantMethod = (RacNode)mClientAwareChecking.generate();
					addNewMethod((JmlMethodDeclaration)invariantMethod);
				}
				else {
					if(Main.aRacOptions.callSiteInstrumentation()){
						InvariantMethodAdviceAsPreconditionMethodCallSite mCallSite = new InvariantMethodAdviceAsPreconditionMethodCallSite(false, typeDecl, varGen);
						RacNode invariantMethod = (RacNode)mCallSite.generate();
						addNewMethod((JmlMethodDeclaration)invariantMethod);
					}
					if(!Main.aRacOptions.noExecutionSiteInstrumentation()){
						RacNode invariantMethod = (RacNode)m.generate();
						addNewMethod((JmlMethodDeclaration)invariantMethod);	
					}	
				}
			}
		}
	}

	protected void translateInvariantAsPostcondition(){
		InvariantMethodAdviceAsPostconditionMethod m = new InvariantMethodAdviceAsPostconditionMethod(false, typeDecl, varGen);
		
		if(Main.aRacOptions.clientAwareChecking()){
			InvariantMethodAdviceAsPostconditionMethodClientAwareChecking mClientAwareChecking = new InvariantMethodAdviceAsPostconditionMethodClientAwareChecking(false, typeDecl, varGen);
			RacNode invariantMethod = (RacNode)mClientAwareChecking.generate();
			addNewMethod((JmlMethodDeclaration)invariantMethod);
		}
		else {
			if(Main.aRacOptions.callSiteInstrumentation()){
				InvariantMethodAdviceAsPostconditionMethodCallSite mCallSite = new InvariantMethodAdviceAsPostconditionMethodCallSite(false, typeDecl, varGen);
				RacNode invariantMethod = (RacNode)mCallSite.generate();
				addNewMethod((JmlMethodDeclaration)invariantMethod);
			}
			if(!Main.aRacOptions.noExecutionSiteInstrumentation()){
				RacNode invariantMethod = (RacNode)m.generate();
				addNewMethod((JmlMethodDeclaration)invariantMethod);	
			}	
		}
		
		// translating inner invariants - [[[hemr]]]
		ArrayList inners = typeDecl.inners();
		if(inners.size() > 0){
			for (Iterator iterator = inners.iterator(); iterator.hasNext();) {
				JmlTypeDeclaration currentInnerType = (JmlTypeDeclaration) iterator.next();
				m = new InvariantMethodAdviceAsPostconditionMethod(false, currentInnerType, varGen);

				if(Main.aRacOptions.clientAwareChecking()){
					InvariantMethodAdviceAsPostconditionMethodClientAwareChecking mClientAwareChecking = new InvariantMethodAdviceAsPostconditionMethodClientAwareChecking(false, typeDecl, varGen);
					RacNode invariantMethod = (RacNode)mClientAwareChecking.generate();
					addNewMethod((JmlMethodDeclaration)invariantMethod);
				}
				else {
					if(Main.aRacOptions.callSiteInstrumentation()){
						InvariantMethodAdviceAsPostconditionMethodCallSite mCallSite = new InvariantMethodAdviceAsPostconditionMethodCallSite(false, typeDecl, varGen);
						RacNode invariantMethod = (RacNode)mCallSite.generate();
						addNewMethod((JmlMethodDeclaration)invariantMethod);
					}
					if(!Main.aRacOptions.noExecutionSiteInstrumentation()){
						RacNode invariantMethod = (RacNode)m.generate();
						addNewMethod((JmlMethodDeclaration)invariantMethod);	
					}	
				}
			}
		}
	}

	/** 
	 * Translates constraint clauses of the target class. This method
	 * produces <em>constraint check methods</em>, <em>old expression
	 * evaluation methods</em>, and <em>old expression fields</em>, to
	 * be added to the translated class.
	 * 
	 * <pre><jml>
	 * also
	 *   assignable classDecl.*;
	 * </jml></pre>
	 *
	 * @see TransConstraint
	 */
	protected void translateConstraint() {
		ConstraintMethod m = new ConstraintMethod(false, typeDecl, varGen);
		if(Main.aRacOptions.clientAwareChecking()){
			ConstraintMethodClientAwareChecking mClientAwareChecking = new ConstraintMethodClientAwareChecking(false, typeDecl, varGen);
			RacNode constraintMethod = (RacNode)mClientAwareChecking.generate();
			addNewMethod((JmlMethodDeclaration)constraintMethod);
		}
		else{
			if(Main.aRacOptions.callSiteInstrumentation()){
				ConstraintMethodCallSite mCallSite = new ConstraintMethodCallSite(false, typeDecl, varGen);
				RacNode constraintMethod = (RacNode)mCallSite.generate();
				addNewMethod((JmlMethodDeclaration)constraintMethod);
			}
			if(!Main.aRacOptions.noExecutionSiteInstrumentation()){
				RacNode constraintMethod = (RacNode)m.generate();
				addNewMethod((JmlMethodDeclaration)constraintMethod);
			}
		}
		
		// translating inner invariants - [[[hemr]]]
		ArrayList inners = typeDecl.inners();
		if(inners.size() > 0){
			for (Iterator iterator = inners.iterator(); iterator.hasNext();) {
				JmlTypeDeclaration currentInnerType = (JmlTypeDeclaration) iterator.next();
				m = new ConstraintMethod(false, currentInnerType, varGen);
				if(Main.aRacOptions.clientAwareChecking()){
					ConstraintMethodClientAwareChecking mClientAwareChecking = new ConstraintMethodClientAwareChecking(false, typeDecl, varGen);
					RacNode constraintMethod = (RacNode)mClientAwareChecking.generate();
					addNewMethod((JmlMethodDeclaration)constraintMethod);
				}
				else{
					if(Main.aRacOptions.callSiteInstrumentation()){
						ConstraintMethodCallSite mCallSite = new ConstraintMethodCallSite(false, typeDecl, varGen);
						RacNode constraintMethod = (RacNode)mCallSite.generate();
						addNewMethod((JmlMethodDeclaration)constraintMethod);
					}
					if(!Main.aRacOptions.noExecutionSiteInstrumentation()){
						RacNode constraintMethod = (RacNode)m.generate();
						addNewMethod((JmlMethodDeclaration)constraintMethod);
					}
				}
			}
		}
	}

	/**
	 * Translates a JML method declaration. A translation of JML method
	 * declaration produces four new methods, and the original method
	 * is renamed and made <tt>private</tt>-accessible:
	 * 
	 * <p>
	 * <ul><li>
	 * <em>Precondition checking method</em>. A <tt>protected</tt> method
	 * to check the precondition of the original method (refer to the class
	 * <code>PreconditionMethod</code>).
	 * </li></ul>
	 *
	 * <ul><li>
	 * <em>Normal and exceptional postcondition checking methods</em>. 
	 * A couple of <tt>protected</tt> methods to check the normal and
	 * exceptional postconditions of the original method
	 * (refer to the classes <code>PostconditionMethod</code> and
	 * <code>ExceptionalPostconditionMethod</code>).
	 * </li></ul>
	 *
	 * <ul><li>
	 * <em>Wrapper method</em>. A wrapper method that wraps the original
	 * method with pre and postcondition checking (refer to the class
	 * <code>WappersMethod</code>).
	 *
	 * <p>
	 * The translation also generate several new instance fields to store
	 * temporally values used by the assertion checking methods. 
	 * There are three kinds of variables that are generated and declared
	 * as instance fields.
	 * 
	 * <p>
	 * <ul><li>
	 * <em>Precondition variables</em>.
	 * </li></ul>
	 *
	 * <ul><li>
	 * <em>Pre (\pre) expression variables</em>.
	 * </li></ul>
	 *
	 * <ul><li>
	 * <em>Old (\old) expression variables</em>.
	 * </li></ul>
	 *
	 * <ul><li>
	 * <em>Specification variables</em>.
	 * </ul></li>
	 *
	 * <p>
	 * Similarly, translation of JML constructor declaration also produces 
	 * four new methods, and the original constructor becomes a wrapper
	 * method (refer to the class <code>TransConstructor</code>).
	 */
	protected void translateMethod(JmlMethodDeclaration mdecl) {
		// no translation for model or main methods
		//if (isMain(mdecl)) {
		//return;
		//}
		if (mdecl.isModel()) {
			// !FIXME! no translation of in-line assertions for medel methods
			translateModelMethod(mdecl);
			return;
		}

		// !FIXME! no visibility checking yet 
		// modUtil.asString(self.modifiers()));

		Object body = mdecl.body();
		if (genSpecTestFile && mdecl.isConstructor()) body = ((JBlock)body).body();
		if (body != null) {
			VarGenerator varGenBody = VarGenerator.forMethod(varGen);
			TransMethodBody transBody = null;
			if (mdecl.isConstructor()){
				transBody = new TransConstructorBody(varGenBody, mdecl, classDecl);
			}
			else{
				transBody = new TransMethodBody(varGenBody, mdecl, classDecl);
			}
			mdecl.setBody(transBody.translate());
		}

		// generate accessor method for spec_public and spec_protected
		//this feature is automatically handled by aspects and it is not necessary to have
		// an accessor method - hemr
		
		/*if (mdecl.isSpecPublic() || mdecl.isSpecProtected()) {
			if (mdecl.isConstructor())
				typeDecl.addMember(specPublicConstructorAccessor(
						(JmlConstructorDeclaration) mdecl));
			else
				typeDecl.addMember(specPublicMethodAccessor(mdecl));
		}*/

		// translate method specification
		TransMethod trans = createMethodTranslator(mdecl);
		trans.perform(mdecl);

		// add newly created methods if any
		Iterator iter = trans.newMethods().iterator();
		while (iter.hasNext()){
			Object object = iter.next();
			//			JMethodDeclarationType jtd = (JMethodDeclarationType)object;
			typeDecl.addMember((JMethodDeclarationType)object);
		}	

		// add newly created fields if any
		if (trans.hasNewFields()) {
			iter = trans.newFields().iterator();
			String fieldDecls = "";
			while (iter.hasNext())
				fieldDecls = fieldDecls + iter.next();
			fieldDecls = "\n// Generated by AspectJML\n" + fieldDecls;
			typeDecl.addMember(RacParser.parseMethod(fieldDecls));
		}

	}

	/** Creates a method translator for the given method declaration. */
	protected TransMethod createMethodTranslator(JmlMethodDeclaration mdecl) {
		return new TransMethod(typeDecl, varGen);
	}

	/**
	 * Translates the given model method (or constructor),
	 * <code>mdecl</code>. !FIXME!describe translation rules.
	 */
		protected void translateModelMethod(JmlMethodDeclaration mdecl) {
			//@ assume mdecl.isModel();
	
			// if not executable, we are done.
			if (!mdecl.isExecutableModel()) {
				return;
			}
	
			// turn it into a Java method or constructor. Perhaps,
			// generate new one instead of mutating it?
			mdecl.setModifiers(mdecl.modifiers() & (~ACC_MODEL));
	
//			mdecl.setModifiers2(mdecl.modifiers2() | ACC2_RAC_METHOD);
	
			// for a constructor, we are almost done
//			if (mdecl.isConstructor()) {
				// if protected or package-visivible, make it public so
				// that dynamic call can be maded to it by subclasses or
				// other classes in the same package.
//				if (!(mdecl.isPublic() || mdecl.isPrivate())) { 
//					long mod = mdecl.modifiers();
//					mod = (mod | ACC_PUBLIC) & (~ACC_PROTECTED) & (~ACC_PRIVATE);
//					mdecl.setModifiers(mod);
//				}
	
//				mdecl.setModifiers2(mdecl.modifiers2() | ACC2_RAC_METHOD);
//				return;
//			}
	
			// for a public or private method, we are done.
//			if (mdecl.isPublic() || mdecl.isPrivate()) {
//				return;
//			}
			String nameAjmlc = "";
			long methodMod = 0;
			if (mdecl.isConstructor()) {
				nameAjmlc = mdecl.getMethod().owner().qualifiedName().replace('/', '.').replace("$", ".") + '.' + "new";
				methodMod = ACC_PUBLIC;
			}
			else{
				nameAjmlc = mdecl.getMethod().owner().qualifiedName().replace('/', '.').replace("$", ".") + '.' + mdecl.getMethod().ident();
				methodMod = ACC_PRIVATE;
			}
			// for a protected and package-visible method, build an access
			// method so that subclasses or other classes in the same
			// package can call it dynamically.
			JmlMethodDeclaration decl = JmlMethodDeclaration.makeInstance( 	// FIXME, This one can changed back to JmlMethodDeclaration if the member variable modifier2 is moved
					mdecl.getTokenReference(),
					(methodMod),
					mdecl.typevariables(),
					mdecl.returnType(),
//					TransUtils.modelPublicAccessorName(mdecl.getMethod()),
					nameAjmlc,
					mdecl.parameters(), 
					mdecl.getExceptions(),
					mdecl.body(), 
					null,
					null,
					null);
	
			decl.setModifiers2(decl.modifiers2() | ACC2_RAC_METHOD);
			if(mdecl.isStatic()){
				decl.setModifiers(decl.modifiers() |ACC_STATIC);
			}
			
			String JMLHelperAnnotation =  ((Float.parseFloat(Main.aRacOptions.source()) > 1.4)? (((JmlSourceMethod)mdecl.getMethod()).isPure()? "\n@JMLHelper()":"") : "");

		
			// finally, add the accessor to the host class
			addNewMethod(RacParser.parseMethod(
					"\n/** Generated by AspectJML to implement the model method " +
					mdecl.ident() + ". */"+JMLHelperAnnotation+"$0", decl));
		}

	/** Returns an access method for the given spec_public (or
	 * spec_protected) method declaration, <code>mdecl</code>. The
	 * returned method has the following code structure.
	 *
	 * <pre>
	 * public [static] T specPublic$m(x1, ..., xn) {
	 *   [return] m(x1, ..., xn);
	 * }
	 * </pre>
	 * 
	 * <pre><jml>
	 * requires mdecl.isSpecPublic() || mdecl.isSpecPublic();
	 * </jml></pre>
	 */
	//	private /*@ non_null @*/ JmlMethodDeclaration specPublicMethodAccessor(
	//			/*@ non_null @*/ JmlMethodDeclaration mdecl) {
	//		JFormalParameter[] parameters = mdecl.parameters();
	//		String ident = mdecl.ident();
	//		CType returnType = mdecl.returnType();
	//		boolean hasReturn = returnType != null && !returnType.isVoid();
	//
	//		// build arguments for delegation call of the form: (x1, ..., xn)
	//		StringBuffer args = new StringBuffer("(");
	//		for (int i = 0; i < parameters.length; i++) {
	//			if (i != 0)
	//				args.append(", ");
	//			args.append(parameters[i].ident());
	//		}
	//		args.append(")");
	//
	//		// build the body
	//		JBlock body = RacParser.parseBlock(
	//				"{\n" +
	//				(hasReturn ? "  return " : "  ") + ident + args + ";\n" +
	//		"}");
	//
	//		// build accessor method
	//		JMethodDeclaration m = new JMethodDeclaration(
	//				mdecl.getTokenReference(),
	//				ACC_PUBLIC | (mdecl.isStatic() ? ACC_STATIC : 0),
	//				CTypeVariable.EMPTY,
	//				returnType,
	//				specPublicAccessorName(ident),
	//				parameters,
	//				mdecl.getExceptions(),
	//				body,
	//				null,
	//				null);
	//
	//		// add javadoc and return the accessor
	//		return RacParser.parseMethod(
	//				"\n/** Generated by JML for the " +
	//				(mdecl.isSpecPublic() ? "spec_public" : "spec_protected") +
	//				" method " + ident + ". */$0", m);
	//	}

	/** Returns an access method for the given spec_public (or
	 * spec_protected) constructor declaration. The
	 * returned method has the following code structure.
	 *
	 * <pre>
	 * public static T specPublic$$init$(x1, ..., xn) {
	 *   return new T(x1, ..., xn);
	 * }
	 * </pre>
	 *
	 * where <code>T</code> is the name of type currently being
	 * translated.
	 * 
	 * <pre><jml>
	 * requires mdecl.isSpecPublic() || mdecl.isSpecPublic();
	 * </jml></pre>
	 */
	//	private /*@ non_null @*/ JmlMethodDeclaration 
	//	specPublicConstructorAccessor(
	//			/*@ non_null @*/ JmlConstructorDeclaration mdecl) {
	//		JFormalParameter[] parameters = mdecl.parameters();
	//		// String ident = MN_INIT;
	//		CType returnType = 
	//			CTopLevel.getTypeRep(typeDecl.getCClass().qualifiedName(), true);
	//
	//		// build arguments for delegation call of the form: (x1, ..., xn)
	//		StringBuffer args = new StringBuffer("(");
	//		for (int i = 0; i < parameters.length; i++) {
	//			if (i != 0)
	//				args.append(", ");
	//			args.append(parameters[i].ident());
	//		}
	//		args.append(")");
	//
	//		// build the body
	//		JBlock body = RacParser.parseBlock(
	//				"{\n" +
	//				"  return new " + typeDecl.ident() + args + ";\n" +
	//		"}");
	//
	//		// build accessor method
	//		JMethodDeclaration m = new JMethodDeclaration(
	//				mdecl.getTokenReference(),
	//				ACC_PUBLIC | ACC_STATIC,
	//				CTypeVariable.EMPTY,
	//				returnType,
	//				specPublicAccessorName(MN_INIT),
	//				parameters,
	//				mdecl.getExceptions(),
	//				body,
	//				null,
	//				null);
	//
	//		// add javadoc and return the accessor
	//		return RacParser.parseMethod(
	//				"\n/** Generated by JML for the " +
	//				(mdecl.isSpecPublic() ? "spec_public" : "spec_protected") +
	//				" constructor. */$0", m);
	//	}

	// ----------------------------------------------------------------------
	// MODEL AND GHOST FIELDS
	// ----------------------------------------------------------------------

	/**
	 * Returns all model fields inherited from the interfaces of this
	 * class, but excluding those also inherited from the superclass
	 * chain.
	 */
	//	private /*@ non_null @*/ JFieldDeclarationType[] interfaceModelFields() {
	//		JFieldDeclarationType[] fields = 
	//			classDecl.getAllInterfaceModelFields();
	//
	//		JmlClassDeclaration superDecl 
	//		= JmlTypeLoader.getJmlSingleton().superClassOf(classDecl);
	//
	//		if (superDecl == null) {
	//			return fields;
	//		}
	//
	//		JFieldDeclarationType[] superFields = 
	//			superDecl.getAllInterfaceModelFields();
	//		if (superFields.length == 0) {
	//			return fields;
	//		}
	//
	//		// filter those inherited through super (too)
	//		Set all = toSet(fields);
	//		all.removeAll(toSet(superFields));
	//
	//		return (JFieldDeclarationType[]) 
	//		all.toArray(new JFieldDeclarationType[0]);
	//	}

	/** Returns a set containing elements from the given array. */
	//	private /*@ non_null @*/ Set toSet(JFieldDeclarationType[] fdecls) {
	//		Set result = new HashSet();
	//		for (int i = 0; i < fdecls.length; i++) {
	//			if (fdecls[i] != null) {
	//				result.add(fdecls[i]);
	//			}
	//		}
	//		return result;
	//	}

	/** 
	 * Returns a default accessor method for a model field. 
	 * The returned method has the following form:
	 * <pre>
	 *  public [static] T model$n() {
	 *    throw new JMLNonExecutableException();
	 *  }
	 * </pre>
	 */
	private JmlMethodDeclaration defaultModelFieldAccessor(CField field)
	{
		final String mod = field.isStatic() ? "static " : "";
		final CType type = field.getType();
		String mn = MN_MODEL + field.ident() + "$" + field.owner().ident();
		String nameAjmlc = field.owner().qualifiedName().replace("/", ".") + "." + field.ident();
//		return RacParser.parseMethod(
//				"\n\n/** Generated by JML to access the model field " + 
//				field.ident() + ". */\n" +
//				"public " + mod + toString(type) + " " + mn + "() {\n" +
//				"  throw JMLChecker.ANGELIC_EXCEPTION;\n" +
//		"}\n");
//		String repMethodAjmlc = (
//				"\n/** Generated by AspectJML to access the model field " + 
//				field.ident() + ". */\n" +
//				"private " + mod + toString(type) + " " + nameAjmlc +";\n");
		return RacParser.parseMethod("");
	}
	/** 
	 * Returns a default access method for a <code>spec_public</code> field. 
	 * The returned method has the following form:
	 * <pre>
	 *  public [static] T spec$n() {
	 *    return x;
	 *  }
	 * </pre>
	 * where <code>x</code> is the name of the given field.
	 */
	protected JmlMethodDeclaration specPublicAccessor(CField field)
	{
		String mod = field.isStatic() ? "static " : "";
		CType type = field.getType();
		String mn = MN_SPEC + field.ident() + (genSpecTestFile?"":"$" + classDecl.ident());

		String field_accessor;
		if(JmlRacGenerator.checking_mode == JmlRacGenerator.WRAPPER) {
			field_accessor = "_chx_get_" + field.ident() + "()";
		} else {
			field_accessor = field.ident();
		} 


		return RacParser.parseMethod(
				"\n\n/** Generated by AspectJML to access the spec_public field " + 
				field.ident() + ". */\n" +
				"public " + mod + toString(type) + " " + mn + "() {\n" +
				"  return " + field_accessor + ";\n" +
		"}\n");
	}

	/** Adds a new method declaration, <code>mdecl</code>, to the 
	 * instrumented class.
	 */
	//@ also
	//@   assignable classDecl.*;
	protected void addNewMethod(JmlMethodDeclaration mdecl) {
		classDecl.addMember(mdecl);
	}

	/** Returns a string form of code that, if executed, returns the
	 * receiver of for a dynamic call. This method is used by the
	 * method <code>dynamicInvocationMethod</code> to define a
	 * subclass-specific dynamic invocation method. 
	 *
	 * <pre><jml>
	 * also
	 * ensures \result.equals("rac$receiver(" +clsName+ ", " +receiver+ ")");
	 * </jml></pre>
	 *
	 * @see TransTypeForAjmlc#dynamicInvocationMethod
	 */
	protected String receiver(String clsName, String clazz, String receiver) {
		return "rac$receiver(" + clsName + ", " + receiver + ")";
	}


	// ----------------------------------------------------------------------
	// DATA MEMBERS
	// ----------------------------------------------------------------------

	/** Target class declaration to be translated.
	 *
	 * <pre><jml>
	 * private invariant classDecl == (JmlClassDeclaration)typeDecl;
	 * </jml></pre>
	 */
	private final /*@ spec_protected non_null @*/JmlClassDeclaration classDecl;

	/** True if a cache for interface surrogates need be generated for
	 * the current class being translated.
	 * 
	 * <pre><jml>
	 * private invariant dynamicInvocationMethodNeeded 
	 *                     ==> surrogateCacheNeeded;
	 * </jml></pre>
	 *
	 * @see #dynamicInvocationMethod
	 * @see #surrogateCacheDeclaration
	 */
	//	private boolean surrogateCacheNeeded = false;
}
