/*
 * Copyright (C) 2008-2009 Federal University of Pernambuco and 
 * University of Central Florida
 *
 * This file is part of AJML
 *
 * AJML is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * AJML is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AJML; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: PreconditionMethodAdvice.java,v 1.0 2009/01/15 05:11:33 henriquerebelo Exp $
 * 
 * This file is based on the original $Id: PreconditionMethod.java,v 1.13 2007/07/19 10:51:36 f_rioux Exp $
 * by Yoonsik Cheon
 */
 
package org.jmlspecs.ajmlrac;

import org.jmlspecs.checker.JmlMethodDeclaration;
import org.jmlspecs.checker.JmlTypeDeclaration;
import org.jmlspecs.util.AspectUtil;
import org.multijava.mjc.JMethodDeclarationType;

/**
 * A class for generating a precondition check method as an AspecJ advice. 
 * The precondition checking code is automatic wrapped with code that checks 
 * the inherited preconditions if any, and throws an appropriate exception to 
 * signal a violation if the precondition is violated.
 *
 * <p>
 * The class implements a variant of the <em>Template Pattern</em>
 * [GoF95], prescribed in the class {@link AssertionMethod}.
 * </p>
 *
 * @see AssertionMethod
 *
 * @author Henrique Rebelo
 * @version $Revision: 1.0 $
 */

public class PreconditionMethodAdvice extends PreOrPostconditionMethod {

	/** Construct a new <tt>PreconditionMethodITD</tt> object. 
	 *
	 * @param mdecl method for which the precondition method is generated
	 * @param hasAssertion <code>true</code> if <code>mdecl</code> has 
	 *                     a precondition specification
	 */
	public PreconditionMethodAdvice(JmlTypeDeclaration typeDecl,
			JmlMethodDeclaration mdecl,
			boolean hasAssertion,
			String saveMethod)
	{
		super(typeDecl, mdecl, saveMethod);

		this.hasAssertion = hasAssertion;
		this.prefix = MN_CHECK_PRE;
		this.methodName = prefix + methodName(mdecl) + "$" + typeDecl.ident();
		this.exceptionToThrow = "JMLEntryPreconditionError";

		// javadoc to be added to the generated method
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		if(isMethodCrosscutSpecChecking){
			this.javadoc = "/** Generated by AspectJML to check the precondition of\n" + 
					" * members intercepted by " + mdecl.ident() + " pointcut. */";
		}
		else{
			this.javadoc = "/** Generated by AspectJML to check the precondition of\n" + 
					" * method " + mdecl.ident() + ". */";
		}
		
	}

	// ----------------------------------------------------------------------
	// GENERATION
	// ----------------------------------------------------------------------

	public JMethodDeclarationType generate(RacNode stmt) {
		throw new UnsupportedOperationException();
	}

	public JMethodDeclarationType generate(RacNode stmt, String pred, String context, String tokenReference, String instrumentationType, long visibility, boolean isEmptySpecCaseWithNonNullPre) {
		StringBuffer code = new StringBuffer("");
		StringBuffer codeTmp = new StringBuffer("");
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		
		if(this.hasAssertion){
			// buildAdviceHeader for precondition checking
			codeTmp = this.buildAdviceHeader("PreconditionAssertionMethod", instrumentationType, visibility, isMethodCrosscutSpecChecking);
			code.append(codeTmp.toString());
			// buildAdviceBody for precondition checking
			code.append(" {\n");
			
			if(isMethodCrosscutSpecChecking){
				code.append("     String runtimeObjectOrStaticType = \"\";\n");
				code.append("     String methSig = \"\";\n");
				code.append("     if(thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
				code.append("       runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
				code.append("       methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
				code.append("       methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
				code.append("     }\n");
				code.append("     else{\n");
				code.append("       if(java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
				code.append("          runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
				code.append("       }\n");
				code.append("       else{\n");
				code.append("          if(thisJoinPoint.getThis() != null){\n");
				code.append("             runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(thisJoinPoint.getThis().hashCode());\n");
				code.append("          }\n");
				code.append("          else {\n");
				code.append("             runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(thisJoinPoint.getTarget().hashCode());\n");
				code.append("          }\n");
				code.append("       }\n");
				code.append("         methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
				code.append("    }\n");		
			}

			pred = AspectUtil.changeThisOrSuperRefToAdviceRef(pred, typeDecl);
			// adding JML quantifierInnerClasses if any
			code.append(this.getQuantifierInnerClasses(pred));
			code.append("     String preErrorMsg = " +this.generateErrorMessage(context, tokenReference, "Precondition_Error", isMethodCrosscutSpecChecking)+";\n");
			code.append("     String evalErrorMsg = "+this.generateErrorMessage(context, tokenReference,"Precondition_EvaluationError", isMethodCrosscutSpecChecking)+";\n");
			code.append("     boolean rac$b = true;\n");
			code.append("     try {\n");
			code.append("      rac$b = "+pred+";\n");
			code.append("     } catch (JMLNonExecutableException rac$nonExec) {\n");
			code.append("        rac$b = ").append(Main.aRacOptions.mustBeExecutable()).append(";\n");
			code.append("     } catch (Throwable rac$cause) {\n");
			code.append("        if(rac$cause instanceof JMLAssertionError) {\n");
			code.append("          throw (JMLAssertionError) rac$cause;\n");
			code.append("        }\n");
			code.append("        else {\n");
			code.append("          throw new JMLEvaluationError(evalErrorMsg + rac$cause);\n");
			code.append("        }\n");
			code.append("     }\n");
			
			if(isMethodCrosscutSpecChecking){
				boolean hasAnyBehavioralSpec = AspectUtil.getInstance().hasBehavioralSpec(this.methodDecl);
				if(hasAnyBehavioralSpec){
					code.append("     boolean canThrow = false;\n");
				}
				else{
					code.append("     boolean canThrow = true;\n");
				}
			}
			else{
				if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){				
					code.append("     boolean canThrow = true;\n");
				}
				else{
					if(isEmptySpecCaseWithNonNullPre){
						code.append("     boolean canThrow = true;\n");
					}
					else {
						code.append("     boolean canThrow = false;\n");
					}
				}
			}
			
			String mn = "";
			if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
				mn = this.methodDecl.getMethod().getJavaName()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
			}
			else{
				mn = "."+this.methodDecl.getMethod().getIdent()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
			}
			if(isMethodCrosscutSpecChecking){
				code.append("     JMLChecker.checkPrecondition(rac$b, canThrow, preErrorMsg, "+visibility+", runtimeObjectOrStaticType+\".\"+methSig);\n");			
			}
			else{
				if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){		
					code.append("     JMLChecker.checkPrecondition(rac$b, canThrow, preErrorMsg, "+visibility+", \""+mn+"\");\n");
				}
				else{
					code.append("     JMLChecker.checkPrecondition(rac$b, canThrow, preErrorMsg, "+visibility+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");
				}	
			}

			code.append("\n").append("   }").append("\n");	
		}
		
		

		return RacParser.parseMethod(code.toString(), stmt);
	}

	// ----------------------------------------------------------------------
	// DATA MEMBERS
	// ----------------------------------------------------------------------

	private boolean hasAssertion;

}
